tag: API
section: claude-md
blocks:
  - id: api-standards
    tier: recommended
    title: "API Service Standards"
    content: |
      ## API Standards

      ### Contract First
      - Define OpenAPI/JSON Schema spec before implementing endpoints.
      - Generate types from spec — don't manually duplicate.
      - Spec is the source of truth. Implementation must match.

      ### Design Rules
      - Version from day one: /api/v1/...
      - Proper HTTP semantics: GET reads, POST creates, PUT replaces, PATCH updates, DELETE removes.
      - Pagination on ALL list endpoints. Never return unbounded results.
      - Consistent response envelope: { data, meta, errors }.
      - Async operations return job ID + polling endpoint, not blocking results.
      - Rate limiting on all public endpoints.

      ### Validation
      - Input validation at API boundary — reject malformed requests before they reach services.
      - Use schema validation (Pydantic, Zod, Joi) not manual if-checks.
      - Validate request body, query params, path params, and headers.
      - Return 422 with specific field errors, not generic 400.

      ### Authentication & Authorization
      - Auth middleware/guards at router level, not checked inside handlers.
      - Role-based or policy-based access control via decorators/middleware.
      - Never trust client-sent user identity — always verify from token/session.

      ### Database & Migrations
      - Schema changes managed through migration files (Prisma Migrate, Knex, Flyway, Alembic).
      - Every migration must be reversible (up + down). Test rollbacks.
      - Never modify a deployed migration — create a new one.
      - Seed data separate from migrations. Test seeds run in CI.

      ### Security (OWASP Top 10)
      - **Injection**: Parameterized queries only. No string concatenation for SQL, commands, or LDAP.
      - **Broken Auth**: Rate-limit login attempts. Enforce strong passwords. Rotate tokens.
      - **Sensitive Data Exposure**: Encrypt at rest (AES-256). Never log PII, tokens, or passwords.
      - **XXE/XSS**: Sanitize all user-generated HTML. Content-Security-Policy headers on all responses.
      - **Broken Access Control**: Enforce ownership checks — users can't access other users' resources.
      - **Security Misconfiguration**: No default credentials. No verbose error messages in production.
        Security headers: X-Content-Type-Options, X-Frame-Options, Referrer-Policy, Permissions-Policy.
      - **CSRF**: Token-based protection on all state-changing endpoints (unless using SameSite cookies + bearer tokens).
      - **Audit logging**: Log WHO did WHAT, WHEN, to WHICH resource. Separate from application logs.
        Immutable. Retained per compliance requirements.

      ### Graceful Shutdown
      - Handle SIGTERM: stop accepting new requests, drain in-flight requests, close DB connections, exit.
      - Kubernetes: readiness probe fails immediately, liveness continues during drain.
      - Shutdown timeout configurable (default: 30s). Force exit after timeout.

  - id: api-deployment
    tier: recommended
    title: "API Deployment & Hosting"
    content: |
      ## API Deployment

      ### Container-Based (Production)
      - Multi-stage Dockerfile: builder stage (install + compile) → runtime stage (minimal image, non-root).
      - Pin base image digests, not just tags. Scan images for CVEs in CI (Trivy, Grype).
      - Push to container registry (ECR, GCR, GHCR) on every merge to main.
      - Orchestrate with Kubernetes, ECS, or Cloud Run. Define resource limits for every container.

      ### PaaS / Quick Deploy
      - **Railway**: Git-push deploy with auto-detected Dockerfile or Nixpacks. Ideal for staging and side projects.
      - **Render**: Free tier + auto-deploy from Git. Native cron jobs, managed Postgres.
      - **Fly.io**: Edge deployment with Firecracker VMs. Good for low-latency APIs. `fly deploy` from CI.
      - All PaaS platforms: use platform env vars for secrets, connect managed DB add-ons, enable auto-sleep
        for non-production to control cost.

      ### Environment Management
      - One Dockerfile, many environments. Same image runs in dev, staging, prod.
      - Health check endpoint (`/health`) returns: status, version, uptime, dependency connectivity.
      - Database connection pooling configured per environment (dev: 5, staging: 20, prod: 50+).
      - Migrations run automatically on deploy (pre-deploy hook or init container). Never manually.

      ### Scaling
      - Horizontal scaling by default. No in-memory session state — use Redis or DB.
      - Auto-scaling rules based on CPU + request queue depth, not just CPU alone.
      - Database read replicas for read-heavy workloads. Connection pooler (PgBouncer) in front of Postgres.
