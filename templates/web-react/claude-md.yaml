tag: WEB-REACT
section: claude-md
blocks:
  - id: react-component-architecture
    tier: recommended
    title: "React Component Architecture"
    content: |
      ## React & Frontend Standards

      ### Component Architecture
      - Atomic Design: atoms → molecules → organisms → templates → pages.
      - Components are pure UI. No API calls, no business logic, no direct state management.
      - Container/Presenter split: containers fetch data, presenters render UI.
      - All components must have TypeScript props interfaces. No `any` types.
      - No inline styles. Use CSS modules, Tailwind, or styled-components consistently.

  - id: react-state-management
    tier: recommended
    title: "State Management"
    content: |
      ### State Management
      - Local state (useState) for UI-only state (open/closed, hover, form inputs).
      - Shared state via context or state library ONLY when 3+ components need the same data.
      - Server state via React Query / TanStack Query / SWR — NEVER manually cache API responses.
      - No prop drilling beyond 2 levels. Use composition (children) or context.

  - id: react-i18n
    tier: recommended
    title: "Internationalization (i18n)"
    content: |
      ### Internationalization — From Day One
      - EVERY user-facing string goes through the i18n system. No hardcoded display text.
      - Use react-i18next or next-intl.
      - Translation keys namespaced by feature: `members.table.header.name`.
      - Date, number, currency formatting via Intl API — never manual formatting.

  - id: react-forms
    tier: recommended
    title: "Forms"
    content: |
      ### Forms
      - Use a form library (React Hook Form or Formik). No manual onChange handlers per field.
      - Validation schema defined separately (Zod, Yup) and shared with backend if possible.
      - All forms must handle: loading state, validation errors, submission errors, success feedback.

  - id: react-api-integration
    tier: recommended
    title: "API Integration"
    content: |
      ### API Integration
      - All API calls go through a centralized API client module.
      - API client handles: auth headers, base URL from config, error transformation, retry logic.
      - Use React Query for all server state.

  - id: react-accessibility
    tier: recommended
    title: "Accessibility (a11y)"
    content: |
      ### Accessibility (a11y) — Non-Negotiable
      - Semantic HTML elements (nav, main, section, article, button — not div for everything).
      - All interactive elements keyboard-accessible. All images have alt text.
      - ARIA labels on non-obvious interactive elements.
      - Color contrast minimum AA (4.5:1 for text).

  - id: react-error-boundaries
    tier: recommended
    title: "Error Handling & Suspense"
    content: |
      ### Error Boundaries
      - Wrap feature areas in Error Boundaries — a crash in one widget must not take down the page.
      - Error boundaries display user-friendly fallback UI with retry action.
      - Log caught errors to monitoring service (Sentry, DataDog, etc.).
      - Never catch errors silently — always report and show feedback.

      ### Suspense & Loading States
      - Use React Suspense for code-split components and async data.
      - Every async operation has three states: loading, success, error. No blank screens.
      - Skeleton loaders preferred over spinners for layout stability (reduces CLS).
      - Optimistic updates for user-driven mutations (like/unlike, form submit).

  - id: react-deployment
    tier: recommended
    title: "React Deployment & Hosting"
    content: |
      ## Frontend Deployment

      ### Platform Selection
      - **Vercel**: First choice for Next.js. Zero-config deploys, edge functions, image optimization built in.
        ISR / on-demand revalidation works natively. Preview deployments on every PR.
      - **Netlify**: Great for static + serverless. Form handling, edge functions, split testing built in.
        Works well with Gatsby, Astro, plain React (via adapter).
      - **Cloudflare Pages**: Unlimited bandwidth, global edge. Best for static or Pages Functions.
      - **AWS Amplify / S3+CloudFront**: Full control, lower cost at scale. More ops overhead.
      - Self-hosted Docker: only when platform restrictions require it.

      ### Build & Deploy
      - CI builds produce a static bundle (`dist/` or `.next/`). Same bundle deploys to staging then prod.
      - Preview deployments for every PR — URL posted in PR comments for stakeholder review.
      - Environment variables injected at build time (`NEXT_PUBLIC_*`, `VITE_*`). No secrets in client bundles.
      - Build cache enabled (Turborepo, Nx, or platform-native). Target < 2 min builds.

      ### Performance Budgets
      - JavaScript budget: < {{js_budget_kb | default: 200}} KB compressed for initial load.
      - Lighthouse CI in pipeline. Fail build if performance score drops below {{lighthouse_min | default: 90}}.
      - Monitor Core Web Vitals in production (Vercel Analytics, web-vitals library, or RUM).

      ### Edge & CDN
      - Static assets served from CDN with immutable cache headers (content-hashed filenames).
      - HTML entry point: short cache (5 min) or stale-while-revalidate.
      - Use edge middleware for: redirects, A/B testing, geo-routing, auth checks (avoid full round-trip).
